class MiniWebSocket {
    constructor(url, options = {}) {
        this.url = url;
        this.ws = null;
        this.room = options.room || null;
        this.history = [];
        this.events = {}; // { evento: [callback1, callback2, ...] }
        this.reconnectInterval = options.reconnectInterval || 1000;
        this.maxReconnectInterval = options.maxReconnectInterval || 16000;
        this.currentReconnect = this.reconnectInterval;
        this.autoReconnect = options.autoReconnect !== false; // padrão true
        this.connect();
    }

    connect() {
        this.ws = new WebSocket(this.url);

        this.ws.onopen = () => {
            console.log("Conectado ao servidor!");
            this.currentReconnect = this.reconnectInterval; // reset reconexão
            this.trigger("open");
            if (this.room) this.send("join_room", { room: this.room });
        };

        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                const { event: eventName, payload, id } = data;

                if (eventName) this.history.push({ eventName, payload, id });
                if (eventName) this.trigger(eventName, payload);

                if (id) this.send("ack", { id });
            } catch (err) {
                console.warn("Mensagem inválida:", event.data);
            }
        };

        this.ws.onclose = () => {
            console.log("Conexão fechada.");
            this.trigger("close");
            if (this.autoReconnect) {
                console.log(`Tentando reconectar em ${this.currentReconnect}ms...`);
                setTimeout(() => this.connect(), this.currentReconnect);
                this.currentReconnect = Math.min(this.currentReconnect * 2, this.maxReconnectInterval);
            }
        };

        this.ws.onerror = (err) => {
            console.error("Erro no WebSocket:", err);
            this.ws.close();
        };
    }

    // Enviar mensagem
    send(eventName, payload = {}, id = null) {
        if (this.ws.readyState === WebSocket.OPEN) {
            const msg = JSON.stringify({ event: eventName, payload, id });
            this.ws.send(msg);
        } else {
            console.warn("WebSocket não está aberto!");
        }
    }

    // Broadcast para a sala
    broadcast(eventName, payload = {}) {
        this.send(eventName, { ...payload, broadcast: true });
    }

    // Registrar listener (suporta múltiplos por evento)
    on(eventName, callback) {
        if (!this.events[eventName]) this.events[eventName] = [];
        this.events[eventName].push(callback);
    }

    // Disparar evento
    trigger(eventName, payload) {
        if (this.events[eventName]) {
            this.events[eventName].forEach(cb => cb(payload));
        }
    }

    // Entrar em sala/canal
    joinRoom(roomName) {
        this.room = roomName;
        this.send("join_room", { room: this.room });
    }

    // Retornar histórico de mensagens
    getHistory() {
        return [...this.history]; // retorna cópia
    }

    // Limpar histórico
    clearHistory() {
        this.history = [];
    }

    // Fechar conexão manualmente
    close() {
        this.autoReconnect = false;
        this.ws.close();
    }
}

// Para usar em Node.js ou navegador
if (typeof module !== "undefined") module.exports = MiniWebSocket;
if (typeof window !== "undefined") window.MiniWebSocket = MiniWebSocket;

// Exemplo de uso
const ws = new MiniWebSocket("ws://localhost:8080");

ws.on("message", msg => console.log(msg));
ws.on("open", () => ws.send("hello", { name: "John Doe" }));
ws.on("close", () => console.log("Conexão fechada."));

ws.send("message", { text: "Hello, world!" });

ws.broadcast("message", { text: "Hello, everyone!" });

ws.joinRoom("room1");

ws.close();

ws.getHistory().forEach(msg => console.log(msg));

ws.clearHistory();

ws.getHistory().forEach(msg => console.log(msg));

ws.getHistory().forEach(msg => console.log(msg));
